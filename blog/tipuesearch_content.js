var tipuesearch = {"pages":[{"title":"About","url":"./pages/about/","tags":"misc","text":"2016Fall 修課成員網誌"},{"title":"協同產品設計實習 第七組行走機構","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-qi-zu-xing-zou-ji-gou.html","tags":"seat table","text":"第七組行走機構 協同產品設計實習課程 第七組行走機構 我是第七組組長負責工作是 onshape上的零件組合,由其他組員繪製零件跟設計後進行組裝跟模擬 工作分配: 40423143:onshape協同畫圖,組裝模擬,分配工作,錯誤回報,小組架構更新 40423114:結構設計,理論分析,錯誤回報 40423141:協同畫圖,錯誤回報 40423146:v-rep模擬,錯誤回報 40423120:實體列印 40423124:實體列印 第七組網誌連結 第七組網誌工作區 零件組裝1:組裝40423143 零件組裝2:組裝40423143 零件組裝3:組裝40423143 以下為組員影片: 設計理論:40423114 設計理論模擬:40423114 Autodesk繪製:40423114 零件繪製:40423141 52mm from 黃羿誠 on Vimeo . 零件繪製:40423141 68mm from 黃羿誠 on Vimeo . 零件繪製:40423141 79mm from 黃羿誠 on Vimeo . 零件繪製:40423141 本體 from 黃羿誠 on Vimeo . onshape工作區 https://cad.onshape.com/documents/274005be1e8241d3c766f9f1/w/964eb62a09323c7d3b75db99/e/5634f93660a4e4f43a6c08e6 等角視圖 設計理論CAD圖 設計理論CAD圖檔下載 CAD圖檔下載區 CAD圖檔下載區 (請以滑鼠右鍵存檔) CAD圖檔下載區 CAD圖檔下載區 (請以滑鼠右鍵存檔) 行走機構下載區 第七組行走機構 (請以滑鼠右鍵存檔) 本體 (請以滑鼠右鍵存檔) 79mm主動桿 (請以滑鼠右鍵存檔) 68mm從動桿 (請以滑鼠右鍵存檔) 52mm連接桿 (請以滑鼠右鍵存檔) 墊片 (請以滑鼠右鍵存檔) V-REP模擬 V-REP模擬由40423146負責 實體切削過程 實體切削由40423120負責: 實體切削由40423124負責: 期末總結心得影片 期末總結心得:修課心得:這半學期除了自己畫了這些零件外,還教會組員如何推資料跟畫零件,每天都應該要排進度,然後接受新的挑戰跟難關,可能還沒辦法做到最好,但至少我們正在努力"},{"title":"協同產品設計實習 第十八週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-shi-ba-zhou-zuo-ye.html","tags":"seat table","text":"期末總結 跟修課心得總結影片 協同產品設計實習課程 第十八週 期末總結心得影片 期末報告自評:60分 以下是期末後影片總覽 第十週: 加減乘除的操作影片: 心得:運算看似簡單,但其實需要去更了解程式的編譯和寫法 第十一週: 任務影片: 國立虎尾科技大學 機械設計工程系 協同產品設計實習 40423143 第十一週任務影片 from 楊智勝 on Vimeo . 第十二週: 影片:齒輪嚙合程式講解 國立虎尾科技大學 機械設計工程系 協同產品設計實習 40423143 第十二週 齒輪嚙合程式講解 from 楊智勝 on Vimeo . 第十三週: 齒輪onshape上操作 國立虎尾科技大學 機械設計系 協同產品設計實習 40423143 楊智勝 第十三週 onshape 齒輪嚙和 from 楊智勝 on Vimeo . 第十四週:無 第十五週: 齒輪協同繪製過程影片: 國立虎尾科技大學 機械設計工程系 協同產品設計實習 40423143 第十五週齒輪協同繪製 from 楊智勝 on Vimeo . 第十六週:無 第十七週: 行走機構零件繪製 零件一 行走機構零件繪製 零件二 零件三 行走機構零件導入v-rep 國立虎尾科技大學 機械設計系 協同產品設計實習 40423143 楊智勝 第十七週 v-rep導入 from 楊智勝 on Vimeo . solvespace組合過程 國立虎尾科技大學 機械設計系 協同產品設計實習 40423143 楊智勝 第十七週 solvespace組合過程 from 楊智勝 on Vimeo . 各組員倉儲中的 Github 檔案推送 40423143 Github 檔案推送過程 40423143-2017springcd-final-1.mp4 from 楊智勝 on Vimeo ."},{"title":"協同產品設計實習 第十七週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-shi-qi-zhou-zuo-ye.html","tags":"seat table","text":"期末前一周簡報 協同產品設計實習課程 第十七週 期末協同查驗與自評 行走機構零件繪製 零件一 行走機構零件繪製 零件二 零件三 行走機構零件導入v-rep 國立虎尾科技大學 機械設計系 協同產品設計實習 40423143 楊智勝 第十七週 v-rep導入 from 楊智勝 on Vimeo . v-rep練習 1.各組員倉儲中的 Github 檔案推送 40423143 Github 檔案推送過程 40423143-2017springcd-final-1.mp4 from 楊智勝 on Vimeo . 2.各組員網誌上的 2D 繪圖, 並將程式碼顯示在繪圖網誌文章中 3.各組員倉儲中的子模組建立與運用, 並將程式碼顯示在繪圖網誌文章中 4.各組員 Solvespace 近端零組件繪圖, 並在各組員網誌中顯示指定的零組件 國立虎尾科技大學 機械設計系 協同產品設計實習 40423143 楊智勝 第十七週 solvespace組合過程 from 楊智勝 on Vimeo . 5.各組員 Solvespace 零件轉入 V-rep, 並設定驅動零件進行動態模擬 6.各組員說明在分組行走機構模擬與實作過程中所扮演的角色, 並利用影片檔說明所負責完成的任務 7.各組以協同方式整合各組組員所完成的倉儲, 網誌與操作影片後, 以學號名稱當作子目錄, 其中放入各組員上述各題所完成的操作影片後, 上傳到各組在系上的 Fossil SCM 倉儲, 並設法用各組的 Github Pages 進行分組簡報. 行走機構 零件 第七組行走機構: 設計理論CAD圖 組合圖 心得:繪製零件過程有組員說Solvespace程式難用,但其實多畫幾次就熟了 零件部分是簡單的,難的部分是協同"},{"title":"協同產品設計實習 第十五週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-shi-wu-zhou-zuo-ye.html","tags":"seat table","text":"齒輪組的囓合協同繪圖 協同產品設計實習課程 第十五週 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"black\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 250 # 齒數 n = 36 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"red\") ctx.beginPath() ctx.fillStyle = \" #ffdb72\" ctx.font = \"50px ScriptS\" ctx.fillText(\"40423143 \",300,300) ctx.stroke() window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 7 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a rb=rp*math.cos(pa*deg) rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear2'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 0.8*(canvas.height/2) # 齒數 n = 36 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") ctx.beginPath() ctx.lineWidth=\"600\" ctx.strokeStyle=\"white\" ctx.moveTo(0,600) ctx.lineTo(800,600) ctx.stroke() ctx.beginPath() ctx.lineWidth=\"3\" ctx.strokeStyle=\"red\" ctx.moveTo(0,300) ctx.lineTo(800,300) ctx.stroke() ctx.beginPath() ctx.fillStyle = \" #2894FF\" ctx.font = \"35px ScriptS\" ctx.fillText(\"40423143 \",330,450) ctx.stroke() window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) # 準備在 id=\"gear4\" 的 canvas 中繪圖 canvas = doc[\"gear4\"] ctx = canvas.getContext(\"2d\") # 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角 # 壓力角 pa 單位為角度 pa = 20 # 第1齒輪齒數 n_g1 = 14 # 第2齒輪齒數 n_g2 = 16 # 第3齒輪齒數 n_g3 = 18 # 第4齒輪齒數 n_g4 = 20 # 第5齒輪齒數 n_g5 = 22 # 第6齒輪齒數 n_g6 = 24 # 第7齒輪齒數 n_g7 = 26 # 第8齒輪齒數 n_g8 = 28 # 第8齒輪齒數 n_g9 = 30 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 m = (0.6*canvas.width)/(n_g1+n_g2+n_g3+n_g4) # 根據模數 m, 計算各齒輪的節圓半徑 rp_g1 = m*n_g1/2 rp_g2 = m*n_g2/2 rp_g3 = m*n_g3/2 rp_g4 = m*n_g4/2 rp_g5 = m*n_g5/2 rp_g6 = m*n_g6/2 rp_g7 = m*n_g7/2 rp_g8 = m*n_g8/2 rp_g9 = m*n_g9/2 #單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, \"red\") # 開始繪製囓合齒輪輪廓 # 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離 x_g1 = canvas.width*0.05+rp_g1 # y 方向繪圖區域上方預留 canvas.height 的 20% y_g1 = canvas.height*0.1+rp_g1 # 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同 x_g2 = x_g1 + rp_g1 + rp_g2 y_g2 = y_g1 # 第3齒輪的圓心座標 x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3 y_g3 = y_g1 # 第4齒輪的圓心座標 x_g4 = x_g1 + rp_g1 + 2*rp_g2 + 2*rp_g3+rp_g4 y_g4 = y_g1 # 第5齒輪的圓心座標 x_g5 = x_g1 + rp_g1 + 2*rp_g2 + 2*rp_g3+rp_g4 y_g5 = y_g4+rp_g4+rp_g5 # 第6齒輪的圓心座標 x_g6 =x_g1 + rp_g1 + 2*rp_g2 + 2*rp_g3+rp_g4 y_g6 = y_g5+rp_g5+rp_g6 # 第7齒輪的圓心座標 x_g7 =x_g6-rp_g6-rp_g7 y_g7 = y_g5+rp_g5+rp_g6 # 第8齒輪的圓心座標 x_g8 =x_g7-rp_g7-rp_g8 y_g8 = y_g5+rp_g5+rp_g6 # 第8齒輪的圓心座標 x_g8 =x_g7-rp_g7-rp_g8 y_g8 = y_g5+rp_g5+rp_g6 # 第9齒輪的圓心座標 x_g9 =x_g7-rp_g7-rp_g8 y_g9 = y_g8+rp_g8+rp_g9 # 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2 # 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖 ctx.save() # translate to the origin of second gear ctx.translate(x_g1, y_g1) # rotate to engage ctx.rotate(math.pi/2) # put it back ctx.translate(-x_g1, -y_g1) # 繪製第一個齒輪輪廓 Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, \"red\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423114 \",x_g1-20, y_g1) ctx.stroke() # 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g2, y_g2) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g2) # put it back ctx.translate(-x_g2, -y_g2) Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, \"orange\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423120 \",x_g2-20, y_g2) ctx.stroke() # 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g3, y_g3) # rotate to engage # math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度 # 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快 # 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度 # -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合 # (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, # 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, # 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3 ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3) # put it back ctx.translate(-x_g3, -y_g3) Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, \"yellow\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423123 \",x_g3-20, y_g3) ctx.stroke() # 將第4齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g4, y_g4) # rotate to engage ctx.rotate(math.pi/2-math.pi/n_g4+(math.pi+math.pi/n_g3)*n_g3/n_g4*2) # put it back ctx.translate(-x_g4, -y_g4) Spur(ctx).Gear(x_g4, y_g4, rp_g4, n_g4, pa, \"green\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423124 \",x_g4-20, y_g4) ctx.stroke() # 將第5齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g5, y_g5) # rotate to engage ctx.rotate(math.pi/2-math.pi/n_g5+(math.pi+math.pi/n_g4)*n_g4/n_g5*2) # put it back ctx.translate(-x_g5, -y_g5) Spur(ctx).Gear(x_g5, y_g5, rp_g5, n_g5, pa, \"blue\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423141 \",x_g5-20, y_g5) ctx.stroke() # 將第6齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g6, y_g6) # rotate to engage ctx.rotate(math.pi/2-math.pi/n_g6+(math.pi+math.pi/n_g5)*n_g5/n_g6*2) # put it back ctx.translate(-x_g6, -y_g6) Spur(ctx).Gear(x_g6, y_g6, rp_g6, n_g6, pa, \"green\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423143 \",x_g6-20, y_g6) ctx.stroke() # 將第7齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g7, y_g7) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g7+(math.pi+math.pi/n_g6)*n_g6/n_g7) # put it back ctx.translate(-x_g7, -y_g7) Spur(ctx).Gear(x_g7, y_g7, rp_g7, n_g7, pa, \"yellow\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423146 \",x_g7-20, y_g7) ctx.stroke() # 將第8齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g8, y_g8) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g8+(math.pi+math.pi/n_g7)*n_g7/n_g8*2) # put it back ctx.translate(-x_g8, -y_g8) Spur(ctx).Gear(x_g8, y_g8, rp_g8, n_g8, pa, \"orange\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40443147 \",x_g8-20, y_g8) ctx.stroke() # 將第9齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g9, y_g9) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g9+(math.pi+math.pi/n_g7)*n_g7/n_g9*2) # put it back ctx.translate(-x_g9, -y_g9) Spur(ctx).Gear(x_g9, y_g9, rp_g9, n_g9, pa, \"purple\") ctx.restore() ctx.beginPath() ctx.fillStyle = \"#0000FF\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40443154 \",x_g9-20, y_g9) ctx.stroke() 齒輪協同繪製過程影片: 國立虎尾科技大學 機械設計工程系 協同產品設計實習 40423143 第十五週齒輪協同繪製 from 楊智勝 on Vimeo . 心得:用好前面二個零件後,後面協同才 是比較麻煩的必須等所有組員畫完才能做組合協同"},{"title":"協同產品設計實習 第十三週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-shi-san-zhou-zuo-ye.html","tags":"seat table","text":"Brython 正齒輪齒面寬輔助設計程式 協同產品設計實習課程 第十三週 各班給兩台實體電腦, 從 Ubuntu 16.04 裝起, 配置正齒輪齒面寬輔助設計程式, 然後設法延伸此網際輔助設計程式, 配置 V-rep、Leo Editor、Fossil SCM server 以及 Nginx 加上以 uwsgi 配置 Python3 網際程式等系統. - 由 WCM 課程學員負責配置好硬體與操作系統, 然後逐步放入網際內容管理系統後, 分別為協同產品設計實習各學員建立帳號, 然後試著完成上述各系統與伺服器的建立. v-rep練習 齒輪onshape上操作 國立虎尾科技大學 機械設計系 協同產品設計實習 40423143 楊智勝 第十三週 onshape 齒輪嚙和 from 楊智勝 on Vimeo . 上課心得:協同的重要性的成分未來只會更多,我們必需更懂如何透過程式來整合所學的一切"},{"title":"協同產品設計實習 第十二週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-shi-er-zhou-zuo-ye.html","tags":"seat table","text":"Brython 繪製三個正齒輪廓嚙合 三種正齒輪嚙合 協同產品設計實習課程 第十二週 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } Set Number of Gears from browser import document as doc from browser import html import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") # 以 button 驅動的事件函式 def setgearnumber(e): ctx.clearRect(0, 0, canvas.width, canvas.height) x = (canvas.width)/2 y = (canvas.height)/2 if doc[\"n1\"].value.isdigit(): n17 = int(doc[\"n1\"].value) else: n17 = 17 if doc[\"n2\"].value.isdigit(): n11 = int(doc[\"n2\"].value) else: n11 = 11 if doc[\"n3\"].value.isdigit(): n13 = int(doc[\"n3\"].value) else: n13 = 13 # 只使用畫布高度的 80% canvas_size = canvas.height*0.4 r17 = canvas_size*n17/(n17+n11+n13) r11 = canvas_size*n11/(n17+n11+n13) r13 = canvas_size*n13/(n17+n11+n13) # 計算各齒輪中心座標 x17 = x - r17-r11 y17 = y x11 = x y11 = y x13 = x + r11+r13 y13 = y pa = 20 # 開始繪製齒輪 # 儲存原有的座標系統 ctx.save() # 平移到齒輪圓心 ctx.translate(x17, y17) # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平 ctx.rotate(90*deg) # 平移回原來的座標原點 ctx.translate(-x17, -y17) gear17 = Spur(ctx).Gear(x17, y17, r17, n17, pa, \"blue\") # 回復原有的座標系統 ctx.restore() ctx.save() ctx.translate(x11, y11) # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合 ctx.rotate(-90*deg-math.pi/n11) ctx.translate(-x11, -y11) gear11 = Spur(ctx).Gear(x11, y11, r11, n11, pa, \"blue\") ctx.restore() ctx.save() ctx.translate(x13, y13) # 右側齒輪轉動 -90 度加上一齒, 可以與原來標線在左側水平的中間齒輪囓合, 但是目前中間齒輪的標線已經轉了 180 度加或減一次 # 必須配合兩齒的速比轉換旋轉角, 以便讓中間齒輪與右側齒輪囓合 ctx.rotate(-90*deg-math.pi/n13+(180*deg+math.pi/n11)*n11/n13) ctx.translate(-x13, -y13) gear13 = Spur(ctx).Gear(x13, y13, r13, n13, pa, \"blue\") ctx.restore() setgearnumber(True) ''' div = doc[\"onegear_div\"] form = html.FORM() input1 = html.INPUT(type=\"text\", id=\"n1\", name=\"n1\", value=\"13\") input2 = html.INPUT(type=\"text\", id=\"n2\", name=\"n2\", value=\"11\") input3 = html.INPUT(type=\"text\", id=\"n3\", name=\"n3\", value=\"19\") div <= input1 + html.BR() + input2 + html.BR() + input3 ''' doc['button'].bind('click',setgearnumber) 影片:齒輪嚙合程式講解 國立虎尾科技大學 機械設計工程系 協同產品設計實習 40423143 第十二週 齒輪嚙合程式講解 from 楊智勝 on Vimeo . 心得:第十二週作業為畫三齒輪嚙合,過程聽老師講解之後實際操作後才會知道程式的問題"},{"title":"協同產品設計實習 第十一週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-shi-yi-zhou-zuo-ye.html","tags":"seat table","text":"Brython 繪製單一正齒輪廓跟任務影片 1.協同閱讀寫心得 An Introduction to Agile Product Design 個人我認為onshape是個很好的繪圖軟體,線上又是公開性也能有版次的紀錄,重點是方便性而本章內容主要是在介紹敏捷產品的優點,及產業用敏捷產品的好處,敏捷的產品主要有兩大好處,推進速度及提高創新,而對公司的好處有四大點1.更快的創新2.降低開發成本3.更大的市場份額4.較高的預測精度 2.影片觀看心得 影片一:直接測試組合件的動作以及可在零組件上加零件並測試 3.2D 靜態網際繪圖-3D 減速齒輪組動態模擬 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=17, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/4 y = (canvas.height)/4 r = 0.8*(canvas.height/4) # 齒數 n = 17 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window import math # 主要用來取得畫布大小 canvas = doc[\"cango_gear\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx ctx = canvas.getContext(\"2d\") cango = window.Cango.new # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 #cobj = window.Cobj.new shape = window.Shape.new path = window.Path.new creategeartooth = window.createGearTooth.new tweener = window.Tweener.new # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"cango_gear\") ###################################### # 畫正齒輪輪廓 ##################################### # n 為齒數 n = 11 # pa 為壓力角 pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth m = 0.4*canvas.width/n # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = shape(data, { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = path(shapedefs.circle(hr)) shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path # setup the animation # backlash (mm) bklsh = 0.04*m # centre shift to make backlash dC = bklsh/(3*math.tan(math.pi*pa/180)) # np 為小齒輪齒數 np = 13 # gear ratio gr = n/np gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]} # gr*0.666 rpm #pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]} # 0.666 rpm twnr = tweener(0, 90000, \"loop\") cx = canvas.width/2 cy = canvas.height/2 #gear.translate(cx, cy) # render 繪出靜態正齒輪輪廓 #cgo.render(gear) #cgo.render(gear2) # 利用 gear 資料複製一份, 命名為 gear gear1 = gear.dup() gear2 = gear1.dup() from time import time from browser.timer import request_animation_frame as raf from browser.timer import set_interval deg = math.pi/180 def draw(): cgo.clearCanvas() gear.rotate(2*deg) # 在特定位置, 以特定 scale, 特定 degs 執行 render cgo.render(gear, {'x':cx-pr/2, 'y':cy, 'scl':0.5, 'degs':0}) gear1.rotate(-2*deg) cgo.render(gear1, {'x':cx+pr*2*0.5-pr/2, 'y':cy, 'scl':0.5, 'degs':0}) gear2.rotate(2*deg) cgo.render(gear2, {'x':cx+pr*2*0.5*2-pr/2, 'y':cy, 'scl':0.5, 'degs':0}) set_interval(draw, 2) 任務影片: 國立虎尾科技大學 機械設計工程系 協同產品設計實習 40423143 第十一週任務影片 from 楊智勝 on Vimeo . 心得:第十一週作業加入了py.的程式編譯一開始不太懂是多跟同學討論後才了解一些"},{"title":"協同產品設計實習 第十週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-shi-zhou-zuo-ye.html","tags":"seat table","text":"倉儲協同 1.+法運算 2.+法運算 3.*法運算 4./法運算 1.+法運算 +法程式碼(add.py) def add (a,b): //def用於定義函式和類型的方法 return a+b //將a+b值傳回主程式中 +法程式碼(print.py) import sys //插入sys檔案中所有函式 sys.path.append(\"./m1\")//資料夾路徑 import add //導入 add.py sum = add.add (1,2) //乘法演算 print(sum) //輸出結果 2.-法運算 -法程式碼(add.py) def add (a,b): //def用於定義函式和類型的方法 return a-b //將a-b值傳回主程式中 -法程式碼(print.py) import sys //插入sys檔案中所有函式 sys.path.append(\"./m1\") //資料夾路徑 import add //導入 add.py sum = add.add (1,2) //乘法演算 print(sum) //輸出結果 3.*法運算 乘法程式碼(add.py) def add (a,b): //def用於定義函式和類型的方法 return a* b //將a乘b值傳回主程式中 乘法程式碼(print.py) import sys //插入sys檔案中所有函式 sys.path.append(\"./m1\") //資料夾路徑 import add //導入 add.py sum = add.add (1,2) //乘法演算 print(sum) //輸出結果 4./法運算 /法程式碼(add.py) def add (a,b): //def用於定義函式和類型的方法 return a/b //將a/b值傳回主程式中 /法程式碼(print.py) import sys//插入sys檔案中所有函式 sys.path.append(\"./m1\") //資料夾路徑 import add//導入 add.py sum = add.add (1,2) // /法演算 print(sum) //輸出結果 5.操作影片: 6.心得: 第十周的這運算看似簡單,但其實需要去更了解程式的編譯和寫法"},{"title":"協同產品設計實習 第九週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-jiu-zhou-zuo-ye.html","tags":"seat table","text":"期中作業 1.Fossil Server 實習查驗 2.四連桿機構協同 Trace Point 查驗 3.Fourbar Walker OnShape 零件協同繪圖與組立查驗 4.分組協同零件展示 1.Fossil Server 實習查驗 ag7期中考報告 fossil 2.Fourbar Walker OnShape 零件協同繪圖與組立查驗 利用OnShape畫Fourbar Walker製作影片 OnShape零件繪製-1 國立虎尾科技大學 機械設計系 協同產品設計實習 40423143 楊智勝 ONSHAPE期中四連桿零件繪製 from 楊智勝 on Vimeo . OnShape零件繪製-2 國立虎尾科技大學 機械設計系 協同產品設計實習 40423143 楊智勝 ONSHAPE期中四連桿 from 楊智勝 on Vimeo . 4.分組協同零件展示 分組協同零件展示 window.onload = function(){ var madeleine = new Madeleine({ target: 'target', // target div id data: './../data/Fourbar1.stl', // data path path: './../work/madeleine/src/' // path to source directory from current html file }); }; select stl file: or drop stl file"},{"title":"協同產品設計實習 第八週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-ba-zhou-zuo-ye.html","tags":"seat table","text":"期中自評跟總結影片和心得 第八週 期中自評 自評80分 第七週 補齊上週的ONSHAPE八連桿組裝 第六週 ONSHAPE八連桿零件-1 ONSHAPE八連桿零件-2 第六週ONSHAPE零件操作 ONSHAPE零件組合 V-REP 國立虎尾科技大學 機械設計工程系 協同產品設計實習 40423143 v-rep 4link 第一段 from 楊智勝 on Vimeo . 第五週 1.為各班各組在 https://mde2a2.kmol.info 主機上建立 cdbg1(完成後可直接連結至 cdbg1 倉儲, 交由組長管理) ~ cdbg8, 以及 cdag1 ~ cdag8 等線上 Fossil SCM 倉儲, 用來管理各組協同產品設計實習過程中的純文件檔案 2.單連桿製作及導入v-rep 導入v-rep 零件繪製 第四週 第七組FOSSIL SCM連結 https://mde2a2.kmol.info/cdag7/home 第三週翻譯英文影片 第二週影片 4連桿 40423143-4連桿 from 楊智勝 on Vimeo . solvespace零件一 solvespace零件二 solvespace零件三 第一週上課筆記 1.利用solvespace及onshape組裝四連桿機構 2.ipv4和ipv6設定 3.分組方式,如何更有效的決定 4.小組組織跟分工的重要性 5.要主動教導不會的同學 6.ipcofig設定 更改stunnel設定檔ip位址 上課心得:第一週上課,分組應要有更有效率的辦法,小組要多溝通分工,雖然組員都不是很會但相信第二組是可以的 零件一 零件二 零件三 組裝影片 組合圖 修課心得:這半學期除了自己畫了這些零件外,還教會組員如何推資料跟畫零件,每天都應該要排進度,然後接受新的挑戰跟難關,可能還沒辦法做到最好,但至少我們正在努力"},{"title":"協同產品設計實習 第七週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-qi-zhou-zuo-ye.html","tags":"seat table","text":"上課筆記 第七週任務 補齊前面缺的東西 ONSHAPE八連桿零件-1 ONSHAPE八連桿零件-2 ONSHAPE八連桿組裝 心得:上課要認真"},{"title":"協同產品設計實習 第六週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-liu-zhou-zuo-ye.html","tags":"seat table","text":"ONSHAPE四連桿零件操作影片和零件組合 第六週ONSHAPE零件操作 ONSHAPE零件組合 V-REP 國立虎尾科技大學 機械設計工程系 協同產品設計實習 40423143 v-rep 4link 第一段 from 楊智勝 on Vimeo . 心得:過程還算順利 ONSHAPE八連桿零件-1 ONSHAPE八連桿零件-2 GITHUB除錯,身為組長排除萬難都要更新成功 心得:頗有成就感"},{"title":"協同產品設計實習 第五週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-wu-zhou-zuo-ye.html","tags":"seat table","text":"把零件導入v-rep操作影片 第五週 1.為各班各組在 https://mde2a2.kmol.info 主機上建立 cdbg1(完成後可直接連結至 cdbg1 倉儲, 交由組長管理) ~ cdbg8, 以及 cdag1 ~ cdag8 等線上 Fossil SCM 倉儲, 用來管理各組協同產品設計實習過程中的純文件檔案 2.單連桿製作及導入v-rep 導入v-rep 上課心得:入v-rep零件還算輕鬆 零件繪製"},{"title":"協同產品設計實習 第四週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-si-zhou-zuo-ye.html","tags":"seat table","text":"FOSSIL SCM連結跟概述 第四週 第七組FOSSIL SCM連結 https://mde2a2.kmol.info/cdag7/home Fossil SCM 是一套軟體配置管理 (Software Configuration Management) 系統, 其中包含分散式版次控管 (DVC, Distributed Version Control) 、Wiki 、Bug Tracking 與 Technote 等功能, 可以用來控制及追蹤軟體開發專案, 並且紀錄專案開發歷程, 在協同產品設計實習課程中, 我們除了使用 git、github 與 bitbucket 之外, 將要在區域網路與系上主幹中, 配置每班兩台的 Fossil SCM 實習主機. 上課心得:新架構,新體驗 當組長要幫助不會的同學,還要分配工作,讓我學到更多東西例如:要多溝通,和多了解程式的意思"},{"title":"協同產品設計實習 第三週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-san-zhou-zuo-ye.html","tags":"seat table","text":"翻譯影片 第三週影片 影片二: 內容: The 2017 HyperWorks release has a lot 在2017年HyperWorks發行很多版本 of enhancements to the modeling and assembly capabilities 對軟件的建模和組裝能力的增強 So we put in a new parts browser with a built-in part library 所以我們在一個新的零件瀏覽器與一個內置零件庫 The part library is a great tool for storing and loading work in progress 零件庫是用於存儲和加載正在進行工作的一個很好的工具 So you can store a catalog of all the common parts 因此，您可以存儲所有公共部分的目錄 that a workgroup needs to use,so they can download their models from their PLM system 工作組需要使用，因此他們可以從他們的PLM系統下載他們的模型 and store them locally in a parts library for a work in progress 並將它們本地存儲在正在進行的工作的零件庫中 And it keeps revision control on them, 他保持對它們的修訂控制 so they can back up to the different versions and reload. 所以他們可以備份到不同的版本並重新加載。 And they can also build different configurations now of their models. 他們也可以建立不同的配置到他們現在的的模型。 In the configuration modeler now 現在在配置建模器 they can import parts from part library and then group 他們可以從零件庫導入零件然後分組 them into what we call part sets,which are 他們變成我們所說的部分集 convenient groupings of parts. 即零件方便分組 And then they can drag those parts together into assemblies, 然後他們可以將這些部分一起拖入組件 and configure them for different load 並為不同負載配置它們的 cases or different variations of their models. 情況或他們的模型的不同變化 the other feature of haveing parts in the software 硬件部分的軟件中的另一個特點 is we do part instancing now,too. 我們現在也做實例化 So if you load in a part that has 所以如果你加載在一個部分 multiple instances through the model,we support that. 我們支持多個實例通過模型 We don't have to create multiple copies of it. 我們不必創建它的多個副本 We can actually do the instancing,which is very memory efficient. 我們可以做實際，這是非常有效的記憶。 Also in the model building assembly 也在模型建築組裝 tool set is enhanced ID management as well. 工具集也是增強的ID管理 So not only can we assign IDs based on different rules 因此，我們不僅可以根據不同的規則分配ID that you define in the software,but you can import ID systems 您可以在軟件中定義，但可以導入ID系統 form spreadsheets,XML files,databases, 形式電子表格，XML文件，數據庫， and so forth,that are then used when 等等，然後在使用 it does the renumbering or the assembly of the model. 它進行重新編號或模型的組裝 it has to resolve part collisions. 它必須解決部分碰撞。 Really important part of doing model assembly 做模型組裝重要的部分 is connecting all those parts together. 將所有這些部分連接在一起 Connectors are really vital to the overall assembly process. 連接器對整個裝配過程至關重要。 The quality of the connector that you create really 您真正創建的連接器的質量 determines the outcome of the quality 確定質量的結果 of the overall assembled model as well. 對整體組裝模型 So for us to get a good high fidelity solution, 所以為我們得到一個良好的高保真度解決方案 you have to have a really good connection generation as well. 你必須有一個非常好的連接生成 翻譯心得: 這是由會英文的組員翻的,是有嘗試去聽但聽不是很懂"},{"title":"協同產品設計實習 第二週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-er-zhou-zuo-ye.html","tags":"seat table","text":"solvespace零件 四連桿繪製操作影片 第二週影片 4連桿 40423143-4連桿 from 楊智勝 on Vimeo . solvespace零件一 solvespace零件二 solvespace零件三 心得:solvespace操作要更熟練一點,中間都會小卡住"},{"title":"設計二甲座位表","url":"./she-ji-er-jia-zuo-wei-biao.html","tags":"seat table","text":"座位表和分組名單 設計二甲座位表 seet 40423143 楊智勝是第二組組長 組員有: 40423120 40423123 40423124 40423141 40423146 40423147 40423154 40423114 上課心得:需要更有效率的分組方式"},{"title":"協同產品設計實習 第一週作業","url":"./xie-tong-chan-pin-she-ji-shi-xi-di-yi-zhou-zuo-ye.html","tags":"PPT","text":"onshape零件繪製和更改stunnel設定檔ip位址 上課筆記 1.利用solvespace及onshape組裝四連桿機構 2.ipv4和ipv6設定 3.分組方式,如何更有效的決定 4.小組組織跟分工的重要性 5.要主動教導不會的同學 6.ipcofig設定 更改stunnel設定檔ip位址 上課心得:第一週上課,分組應要有更有效率的辦法,小組要多溝通分工,雖然組員都不是很會但相信第二組是可以的 零件一 零件二 零件三 組裝影片 組合圖 組裝心得:算是簡單"}]};